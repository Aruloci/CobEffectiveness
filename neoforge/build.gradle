plugins {
    id 'dev.architectury.loom'
    id 'architectury-plugin'
    id 'com.gradleup.shadow'
}

architectury {
    platformSetupLoomIde()
    neoForge()
}

loom {
    enableTransitiveAccessWideners.set(true)
}

configurations {
    common {
        canBeResolved = true
        canBeConsumed = false
    }
    compileClasspath.extendsFrom common
    runtimeClasspath.extendsFrom common
    developmentNeoForge.extendsFrom common

    shadowBundle {
        canBeResolved = true
        canBeConsumed = false
    }
}

dependencies {
    neoForge "net.neoforged:neoforge:$rootProject.neoforge_version"

    // Cobblemon
    modImplementation("com.cobblemon:neoforge:${rootProject.cobblemon_version}") { transitive = false }

    // Kotlin for NeoForge
    forgeRuntimeLibrary("thedarkcolour:kotlinforforge-neoforge:${rootProject.kotlin_for_forge_version}") {
        exclude group: "net.neoforged.fancymodloader", module: "loader"
    }

    common(project(path: ':common', configuration: 'namedElements')) { transitive = false }
    shadowBundle project(path: ':common', configuration: 'transformProductionNeoForge')

    // tests (optional)
//    testImplementation "org.junit.jupiter:junit-jupiter-api:$rootProject.junit_version"
//    testRuntimeOnly  "org.junit.jupiter:junit-jupiter-engine:$rootProject.junit_version"
}

processResources {
    inputs.property 'version', project.version
    filesMatching('META-INF/neoforge.mods.toml') {
        expand(project.properties)
    }
}

tasks.named('jar') {
    archiveClassifier = 'dev-slim'
}

shadowJar {
    exclude "fabric.mod.json"
    configurations = [project.configurations.shadowBundle]
    archiveClassifier = 'dev-shadow'
}

remapJar {
    dependsOn shadowJar
    inputFile.set shadowJar.archiveFile
}
